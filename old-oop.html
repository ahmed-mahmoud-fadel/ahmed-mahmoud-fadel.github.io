 <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
 <html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
        <link rel="alternate" type="application/rss+xml" title="RSS" href="http://localhost/index.rss" >
        <link rel="stylesheet" media="screen" href="https://fontlibrary.org/face/droid-arabic-naskh" type="text/css"/> 
        <title> : البرمجة الكائنية في بيرل ( الجزء الثاني ) " الطريقة القديمة "</title>
        <style type="text/css" media="screen, print, projection">
       body,
       html {
              margin:0;
              padding:0;
              color:#000;
              background:#fff;
       }
       #wrap {
              width:900px;
              margin:0 auto;
              background:#ffff;
       }
       #header {
       padding:5px 10px;
              background:#ffff;
       }
       h1 {
           margin:0;
    }
       #nav {
              padding:5px 10px;
              background:#ffff;
       }
       #nav ul {
              margin:0;
              padding:0;
              list-style:none;
       }
       #nav li {
              display:inline;
              margin:0;
              padding:0;
       }
       #main {
              float:left;
              width:900px;
              padding:0px;
              background:#ffff;
       }
       h2 {
              margin:0 0 1em;
       }

       #footer {
              clear:both;
              padding:5px 10px;
              background:#ffffff;
       }
       #footer p {
              margin:0;
    }
       * html #footer {
              height:1px;
       }

    a:link {color:#15153E;text-decoration:none;}
       a:visited {color:#000000;text-decoration:none;}
a:hover {color:#38B085;text-decoration:underline;}
       </style>

     </head>
    <body>
    <div id="wrap">
    <div align="center"><h2>
  <div style="font-family: 'Droid Arabic Kufi', serif;">::
  <a href="https://alyassen.github.io">كل المقالات</a> ::
   </div></h2>

  </div>    
    
        <h2>Fri, 11 Sep 2015</h2>
 <div id="main">
  <div dir=rtl><div style="font-family: 'Droid Arabic Naskh', serif;">
  <h3>البرمجة الكائنية في بيرل ( الجزء الثاني ) " الطريقة القديمة "</h3></div>
  <div style="font-family: 'Droid Arabic Naskh', serif;">
بسم الله الرحمن الرحيم <br>

في هذا الجزء سنحاول ان نستعرض النموذج القديم في بيرل و نتعرف على طريقة كتابة البرمجة الكائنية بشكلها القديم . هذه الايام نادرا ما نحتاج الى الكتابة بالطريقة القديمة و لكن المعرفة - و لو الاجمالية - ستكون مفيدة جدا و ذلك لنقاط نذكر منها : <br>

-         قد نحتاج الى قراءة او تعديل اكواد مكتوب بالطريقة القديمة خاصة ان بيرل لغة قديمة و هناك الكثير من المشاريع و البرامج القديمة التي لا تزال قيد الاستخدام. <br>

-         معرفة الطريقة القديمة تعطينا معرفة اجمالية بأساسيات البرمجة الكائنية في بيرل و بذلك يكون لدينا عمق اكبر في فهم الطريقة الجديدة . <br>

-         معرفة الطريقة القديمة تعطينا بعدا جديدا في معرفة كيفية تطبيق النماذج الكائنية في لغات البرمجة فالاشخاص الذين تعلموا البرمجة الكائنية من خلال جافا او بايثون او سمولتولك قد تكون نظرتهم الى البرمجة الكائنية فقط من منظار ما يقدمه نموذج هذه اللغات لذلك معرفة طريقة بيرل المغايرة  - او طريقة جافا سكربت كمثال اخر- يعطي سعة في الاطلاع و كأنه دراسة مقارنة. <br>

-         الطريقة القديمة تقدم نموذجا شبه متكامل من خلال التوليف بين مزايا بسيطة موجودة في اصل اللغة، من خلالها ندرك ان النموذج الكائني قد لا يحتاج الى ذلك التعقيد . <br>

-         النموذج القديم الى الان يستخدمه البعض خاصة في المشاريع البسيطة و المتوسطة لسرعته و لكونه مضمنا في لغة البرمجة و بذلك يقل عدد الاعتماديات الخارجية للبرنامج . <br>

طبعا لن نحاول ان نستقصي كل ما يتعلق بهذا النموذج فهذا يحتاج الى كتب مفصلة و يمكن الرجوع الى كتاب الدكتور دامين كانوي المعنون بـ البرمجة الكائنية في بيرل  (1) ، و لكن سنحاول ان نستعرض الاساسيات التي تكلمنا عنها بشكل نظري في الجزء الاول . <br>

قلنا سابقا ان البرمجة الكائنية هي عملية محاكاة للواقع من خلال النظر الى الاجزاء البرمجية على انها كائنات تشبه الكائنات التي نراها في الواقع الخارجي . هذا كلام جميل من الناحية النظرية و لكن كمبرمجين نريد شيئا ملموسا اكثر ، فنقول ان الكائن هو عبارة عن بيانات مرفق معها العمليات التي يمكن ان تجري عليها او بعبارة اخرى كما احب ان اسميها بيانات ذكية ! لنأخذ مثالا لتتضح الصورة : <br>

عادة عندما يعلموننا لغات البرمجة يبداون بتعليمنا البرمجة الاجرائية و في البرمجة الاجرائية هناك بيانات data structures و هناك اجراءات procedures . لنقل ان لدي شكل من اشكال البيانات لنقل قيمة نصية :

<div dir=ltr>
"this is a data "
</div>
و لنقل انني اريد ان اعرف كم طول النص (عدد الحروف فيه ) ففي البرمجة الاجرائية سأقوم بانشاء اجراء مفصل فيه خطوات معرفة طول القيم و سأسميه ()length 
ثم اقوم بتمرير القيم النصية كلما احتجت ان اعرف طولها بهذا الشكل : <br>
<div dir=ltr>
length("this is a data") </div>

نلاحظ ان هناك ثنائية فالبيانات شيء و الاجراءات شيء اخر و لكن في البرمجة الكائنية نقوم بتوحيد البيانات مع الاجراءات ان صح التعبير فتكون البيانات ذكية بحيث يمكنني ان اسالها مباشرة و هي تجيب عن اسئلتي ، فلو اردت ان اعرف طول النص فيمكنني ان اسال الكائن مباشرة : <br>
<div dir=ltr>
myString.length() </div>

الان لندخل في الشرح التطبيقي لطريقة كتابة كلاسات بالطريقة القديمة : <br>

اول خطوة هي الاعلان عن كلاس جديد و ذلك باستخدام الكلمة المفتاحية package :    <br>

<div dir=ltr> package Person;  </div>

تجدر الاشارة هنا ان لغات مثل جافا تفرض ان يكون لكل كلاس ملفا خاصا به  و لا يشاركه فيه غيره و لكن في بيرل لا يوجد شيء من هذا القبيل - الا اذا استخدمنا امر use parent كما سيأتي- ، فيمكننا ان نعلن عن عدة كلاسات في ملف مصدري واحد . و عادة نحفظ الملف المصدر لكلاسات بيرل بامتداد .pm . جميل ، بعد الاعلان عن اسم الكلاس يمكننا البدء في كتابة تفاصيل الكلاس.  لنشرع في كتابة الكونستركتر و هو عبارة عن ميثود "فعل" يقوم بانشاء كائن جديد و هذا الميثود في جافا يجب ان يكون باسم new و لكن في بيرل مرة اخرى لا يوجد الزام بهذا الامر و يمكن ان نسمي هذا الميثود اي اسم اخر. مهمة هذا الميثود هو ان ينشيء كائنا جديدا من الكلاس المعني بالاضافة الى اسناد القيم الى الخصائص . نعلن عن الميثود بالكلمة المفتاحية sub : <br>

<div dir=ltr> sub new { </div>

ثم نقوم باستقبال نوع الكائن من خلال الامر shift <br>

<div dir=ltr> my $class = shift; </div>

ثم نشرع بتحديد الخصائص و كيفية استقبالها للقيم (نلاحظ اننا لم نعلن عن تلك الخصائص سلفا كما في جافا و كما سيأتي في النموذج الجديد !) <br>
<div dir=ltr>
my $self = {
<br>
        name => shift,
<br>
        national_id  => shift
<br>
    }; </div>

هنا نقطة مهمة حيث اننا في الكود اعلاه حددنا اننا سنقوم بتخزين الخصائص على شكل هاش (قاموس ) و هذا هو الغالب عند مبرمجي بيرل و لكن في بيرل يمكن تغير ذلك الى اي نوع اخر مثلا قائمة array .

الان يمكننا ان نستدعي دالة bless و هي التي تقوم بجمع البيانات و الاجراءات و تحويلها الى كائنات . <br>
<div dir=ltr>
  bless $self, $class; </div>

اخيرا نرجع الكائن : <br>
<div dir=ltr>
return $self;<br> 
}  #end of new() <br>
</div>

الان هذا يعتبر كلاسا كاملا و لكن نحتاج الى ان ننهي تعريف الكلاسات في النموذج القديم بقيمة صحيحة: <br>
<div dir=ltr>
1; </div>

الى الان لدينا كلاس و هذا الكلاس لا يحتوي الا على ميثود واحد اساسي يقوم باسناد القيم الى الخصائص و يرجع كائنا جديدا . اما طريقة انشاء كائن جديد من هذا الكلاس فبهذه الطريقة : <br>
<div dir=ltr>
my $person = Person->new("Ali Yassen", 110009823); </div>

نلاحظ ان في بيرل 5 و على خلاف اغلب لغات البرمجة معامل تنفيذ الميثودز هو السهم -> و ذلك لان في بيرل معامل النقطة  " . " محجوز لامر اخر الا و هو دمج ( وصل ) قيمتين . تجدر الاشارة الى ان في بيرل 6 تم استبدال هذا المعامل بمعامل النقطة . <br>

لو اردنا ان نعرف اسم الكلاس الذي ينتمي اليه اي كائن فبيرل توفر دالة مهمتها فقط ان ترجع نوع الكائن، هذه الدالة اسمها blessed و نمرر اليها اسم المتغير : <br>
<div dir=ltr>
use Scalar::Util qw(blessed);<br>
print blessed($person);  </div>

حسنا لنعد الى الكلاس مرة اخرى و لنضف اليه ما يعرف بالميثودات المساعدة و هي عبارة عن ميثودات تقوم فقط باسترجاع قيم الخصائص gettersاو الاسناد اليها setters و هي بذلك تساعد على الكبسلة بدلا من الوصول المباشر الى قيم الخصائص. و هذا الامر مهم جدا خاصة في بيرل اذ اننا كما اشرنا اعلاه نستطيع ان نمثل البيانات باشكال مختلفة فعندما نعزلها عن الوصول المباشر سيكون بامكاننا لاحقا ان ننتقل الى تمثيل مختلف للبيانات و ان نجري اي تعديلات اخرى بدون التأثير على المبرمجين الذي يعتمدون على اكوادنا . <br>
<div dir=ltr>
sub get_name { <br>
my $self = shift; <br>
return $self->{name}; <br>
} <br>
<br>
sub get_national_id {<br>
my $self = shift;<br>
return $self->{national_id};<br>
}
</div>

لا شيء مميز في الاكواد اعلاه مجرد ارجاع لقيم الخصائص . اما الـ setters :  <br>
<div dir=ltr>
sub set_name { <br>
my ($self , $name ) = (shift, shift); <br>
if (defined $name) 
{ <br>
$self->{name} = $name; <br>
return 1; 
} <br>
}
</div>

هنا فقط قمنا باسناد القيمة الممررة الى خانة name و قمنا بارجاع قيمة 1 في حال لو اردنا الية للتشيك على نجاح العملية . اما الـ national_id فلا نحتاج الى انشاء setter  لها لانها قيمة ثابتة فهل سمعتم عن شخص غير رقمه الوطني ؟!

الان عرفنا طريقة انشاء الميثودز و نستطيع بنفس الطريقة ان ننشيء ما نشاء من الميثودز مثلا الميثود المشهور  toString و هو ميثود يستخدم لانشاء نسخة مكتوبة  تسهل قراءتها  تشمل تفاصيل الكائن .  <br>

لنواصل الكلام و لكن هذه المرة عن التوارث فقد قلنا سابقا ان في بيرل يمكن الوراثة من اكثر من كلاس و ان كان هذا الامر غير مستحسن و ينصح باستخدام الرولز  roles بدلا عن ذلك . لنقل اننا نريد ان ننشيء كلاسا جديدا اسمه student هذا كلاس الطالب يعتبر نوعا من انواع كلاس person و يرث كل ما عند الكلاس الاب  من خصائص و افعال و للحصول على هذه العلاقة و التي تعرف بعلاقة is-a نستخدم هذا الامر :  <br>
<div dir=ltr>
package Student;<br>
use parent 'Person';
</div>
لنفترض الان اننا نريد ان نضيف قيمة جديدة الى خصائص الطالب مثلا عمر الطالب و لكن الكونستركتر الذي ورثناه من كلاس الاب لا يحتوي الا على الاسم و الرقم الوطني ؟ في هذه الحالة نقوم بما يعرف بالميثود اوفررايد override  و هي بعبارة مبسطة عملية تعديل الميثودات الموروثة من الاب و ذلك من خلال الامر SUPER. اذا لنقم باعادة ترتيب الكونستركتر لكي يضيف خانة للعمر :  <br>
<div dir=ltr>
sub new { <br>
my $class = shift; <br>
my $self = $class->SUPER::new(shift,shift); <br>
$self->{age} = shift; <br>
bless $self, $class; <br>
return $self; <br>
}
</div>
ثم نقوم بانشاء ميثودات مساعدة جديدة لـ age  فقط اذ اننا ورثنا المساعدات الاخرى من كلاس الاب . هنا ايضا سأضيف ميثودا مساعدا لكلاس الطالب حيث سأسميه to_string  مهمته فقط ان يرجع قيمة كتبية للكائن :<br>
<div dir=ltr>
sub to_string { <br>
	my $self = shift; <br>
	print "Student name is : " . $self->get_name . "\n" . <br>
	      "Student national id is : " .  $self->get_national_id . "\n" . <br>
	      "Student age is : " . $self->get_age . "\n" <br>
	}
</div>
الان عندما ننشيء كائنا جديدا من نوع طالب بالامر المعتاد :  <br>
<div dir=ltr>
my $student = Student->new("Ali", 110009 , 23);</div>
و عندما نستخدم الميثود المساعد : <br>
<div dir=ltr>
print $student->to_string; </div>
فالنتيجة :  <br>
<div dir=ltr>
Student name is : Ali <br>
Student national id is : 110009 <br>
Student age is : 23 </div>

الان بقي ان نذكر شيئا عن ما يعرف بـ "التركيب " composition  و هذا المصطلح بكل بساطة يعني ان يكون احد الكائنات مكونا من كائن اخر او اكثر ، مثلا في مثالنا ممكن ان نضيف في خانة الخصائص للطالب خانة جديدة باسم bank account بحيث ان رقم الحساب هذا انما هو كائن في حد ذاته و ليس مجرد قيمة رقمية ، فمثلا قد يكون فيه رقم الحساب البنكي و اسم البنك و معلومات الدخول ...الخ. للوصول الى هذه النتيجة فقط نضيف خانة بإسم bank_account في الكونستركتر الخاص بالطلاب و عندما ننشيء كائنا من نوع طالب نمرر له كائن الحساب البنكي مثلا هكذا : <br>
<div dir=ltr>
my $student = Student->new("Ali", 110009 , 23, $bank_account_object);
 </div>
هل لاحظتم اننا تكلمنا عن الميثود اوفر رايد و لم نتكلم عن الميثود اوفر لود Overload و هو كما قلنا سابقا عملية انشاء ميثودات بنفس الاسم و لكن تختلف من ناحية عدد المتغيرات التي تقبلها مثلا : <br>
<div dir=ltr>
method() <br>
method(String astring) <br>
mehtod(String astring, Int myNumber) ...etc <br>
</div>
لم نتكلم عن هذا الجانب لان بيرل ديناميكية و يمكنها ان تتعامل مع اعداد مختلفة من المتغيرات باستخدام ميثود واحد بحيث هذا الميثود يختار الاوامر المناسبة على حسب عدد المتغيرات الممررة . <br>
على كل حال لنكتفي بهذا القدر و الا سيطول بنا المقام و لن نستوفي الموضوع و لكن هذه تقريبا خلاصة المطلب و اساس النموذج القديم . <br>
<br>
دمتم في الرضا ، <br>
---
<div dir=ltr>(1) Object Oriented Perl: A Comprehensive Guide to Concepts and Programming Techniques</div> 



 

 

 

 

 

 

 </div>
 </div>
<div id="footer" align="center">
<br>           
  <a href="http://blosxom.sourceforge.net/"><img src="/img/pb_blosxom.gif" alt="powered by blosxom" border="0" width="90" height="33" ></a>
       </div>
	   
    </body>
</html>